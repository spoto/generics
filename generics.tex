\documentclass{llncs}

\usepackage{url}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{pdfpages}
\usepackage{relsize}
\usepackage{tcolorbox}

\usepackage{svg}
\newcommand{\orcid}[1]{\href{https://orcid.org/#1}{\includesvg[height = 2ex]{svg-inkscape/ORCID_iD}}}

\newcommand{\ie}{\textit{, ie.\ }}

\def\codesize{\smaller}
\def\<#1>{\codeid{#1}}
\newcommand{\codeid}[1]{\ifmmode{\mbox{\codesize\ttfamily{#1}}}\else{\codesize\ttfamily #1}\fi}

\usepackage{listings, xcolor}

\renewcommand{\UrlFont}{\ttfamily\codesize}

\definecolor{verylightgray}{rgb}{.97,.97,.97}

\lstdefinelanguage{Takamaka}{
        keywords=[1]{abstract, break, case, catch, class, continue, default, do
, else, false, finally, for, if, final, implements, extends, import, instanceof, interface, length, new, private, protected, public, return, super, switch, this, throw, true, try, while, var, null}, % generic keywords
        keywordstyle=[1]\color{blue}\bfseries,
        keywords=[2]{boolean, int, long, float, double, byte, short, char, void, enum}, % types; money and time units
        keywordstyle=[2]\color{teal}\bfseries,
        keywords=[3]{@Override,@View,@FromContract,@Payable}, % annotations
        keywordstyle=[3]\color{violet}\bfseries,
        identifierstyle=\color{black},
        sensitive=false,
        comment=[l]{//},
        morecomment=[s]{/*}{*/},
        commentstyle=\color{gray}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        morestring=[b]',
        morestring=[b]"
}

\lstset{
        language=Takamaka,
        backgroundcolor=\color{verylightgray},
        extendedchars=true,
        basicstyle=\scriptsize\ttfamily,
        showstringspaces=false,
        showspaces=false,
        numbers=none,
        numberstyle=\scriptsize,
        numbersep=9pt,
        tabsize=2,
        breaklines=true,
        showtabs=false,
        captionpos=b
}

\begin{document}

\title{Power and Pitfalls of Generic Smart Contracts}
\titlerunning{Power and Pitfalls of Generics for Smart Contracts}
\author{Andrea Benini \and Sara Migliorini \and Fausto Spoto}
\institute{Dipartimento di Informatica, Universit\`a di Verona, Italy}

\maketitle

\begin{abstract}
  TBD
  \keywords{smart contract \and generics \and blockchain}
\end{abstract}

\section{Introduction}\label{sec:introduction}

Blockchains exploit the redundant, concurrent execution of the same
transactions on a decentralized network of many machines
in order to enforce their execution in accordance to
a set of predefined rules. Namely, blockchains make it hard, for a single machine,
to disrupt the semantics of the transactions or their ordering: a misbehaving single machine
gets immediately put out of consensus and isolated. Bitcoin~\cite{Nakamoto08,book-mastering-bitcoin}
has been the first blockchain's success story. Here
transactions are programmed in a non-Turing complete bytecode language,
almost exclusively used to implement transfers of units of coins between \emph{accounts}.

A few years after Bitcoin, another blockchain, called
Ethereum~\cite{Buterin13,AntonopoulosW18}, introduced the possibility of programming
transactions in an actual, imperative and Turing-complete programming language, called Solidity.
Solidity's code is organized in \emph{smart contracts}, that can be seen as
objects that control money.
Ethereum's transactions can hence execute much more than coin transfers. Namely,
they run object constructors and methods, which results in a sort
of \emph{world computer} that persists the same objects in the memory of all the
computers in the blockchain's network.

In Solidity's bytecode,
non-primitive values are referenced through a very general
\<address> type. For instance, a Solidity method
\<child(Person p, uint256 n) returns Person> actually compiles
into \<child(address p, uint256 n) returns address>, losing most
type information~\cite{CrafaPZ19}.
At run time, it is the bytecode that gets executed. Hence,
everything can be passed for \<p>, not just a \<Person>.
The compiler cannot even enforce strong typing
by generating defensive type instance checks and casts, since
values are unboxed in Ethereum: they have no attached
type information at run time,
they are just numerical \emph{addresses}.
It follows that calls to \<Person>'s methods
on \<p> might actually execute arbitrary code, if \<p> is not a \<Person>.
In other words, Solidity is not strongly typed.
Consequently, it is highly discouraged, in Solidity, to call methods on parameters passed
to our methods, such as on \<p> passed to \<child>, since an attacker can pass crafted
objects for \<p>, with arbitrary implementations for their methods,
which can result in the unexpected execution of
dangerous code. This actually happened in the case of the infamous DAO hack~\cite{dao16}, that
costed millions of dollars.

Strong typing is one of the reasons that push towards the adoption
of \emph{traditional} programming languages for smart contracts. For instance,
the Cosmos blockchain~\cite{cosmos} uses Go. The
Hotmoka blockchain~\cite{hotmoka} uses a subset of Java
for smart contracts, called Takamaka~\cite{Spoto19,Spoto20}.
Hyperledger~\cite{hyperldeger} allows Go and Java.
Another reason is the availability of modern
language features, missing in Solidity,
such as \emph{generics}\ie the possibility of using
type variables. Generics are powerful and very useful for programming
smart contracts. In Java source code, they are strongly typed, if no \emph{unchecked operations}
are used~\cite{NaftalinW06}, as it will always be the case in this paper.
However, generics in Java are compiled by \emph{erasure}\ie replaced
by their upwards bound, most often \<Object>. Hence, the risk
is that generics introduce the same kind of attack to the bytecode
as normal reference types do in Solidity.

The contribution of this paper is to show a real-life
use of generics for an actual smart contract used in the support
library of the Takamaka language, and to show that a naive use
of Java generics can lead to a code security vulnerability that
allows an attacker to earn money by exploiting someone else's work.
This paper will provide a fix to that specific issue,
by obliging the compiler to generate defensive checks.
More generally, this paper can be useful for the definition of
bytecode languages for future smart contract languages, by
learning from the weaknesses of Java bytecode.

The rest of this paper is organized as follows.
Sec.~\ref{sec:shared_entities} introduces our real-life Java smart
contracts that uses generics. Sec.~\ref{sec:attack} shows that a naive
deployment of that contract leads to a code vulnerability.
Sec.~\ref{sec:fix} shows a fix to that vulnerability.
Sec.~\ref{sec:conclusion} concludes.

\section{Shared Entities using Generics}\label{sec:shared_entities}

A \emph{shared entity} is something divided into \emph{shares}. Participants,
that hold shares, are called \emph{shareholders} and can dynamically
sell and buy shares. An example of a shared entity is a comporation,
where shares represent units of possess of the company. Another example is
a voting community, where shares represent the voting power of each given voter.
A further example are the validator nodes of a proof of stake blockchain,
where shares represent their voting power and remuneration percentage.

\begin{figure}[t]
  \begin{center}
    \begin{lstlisting}[language=Takamaka]
public interface SharedEntity<S extends PayableContract,O extends Offer<S>> {

  @View
  BigInteger sharesOf(S shareholder);

  @FromContract(PayableContract.class) @Payable
  void place(BigInteger amount, O offer);

  @FromContract(PayableContract.class) @Payable
  void accept(BigInteger amount, S buyer, O offer);

  List<S> getShareholders();

  class Offer<S extends PayableContract> extends Storage {
    public final S seller;
    public final BigInteger sharesOnSale;
    public final BigInteger cost;
    public final long expiration;

    public Offer
        (S seller, BigInteger sharesOnSale, BigInteger cost, long duration) {

      this.seller = seller;
      this.sharesOnSale = sharesOnSale;
      this.cost = cost;
      this.expiration = now() + duration;
    }

    @View
    public boolean isOngoing() {
      return now() <= expiration;
    }
  }
}
    \end{lstlisting}
  \end{center}
  \caption{A simplified part of our shared entity interface.
  Its full code is available at \url{https://github.com/Hotmoka/hotmoka/blob/master/io-takamaka-code/src/main/java/io/takamaka/code/dao/SharedEntity.java}.}\label{fig:shared_entity}
\end{figure}

In general, two concepts are specific to each implementation of shared entities:
who are the potential shareholders and how offers for selling shares work.
Therefore, we have parameterized the interface of a shared entity with two type variables:
\<S> is the type of the shareholders and \<O> is the type of the offers for selling shares.
Fig.~\ref{fig:shared_entity} shows a simplification of our interface.
It includes an inner class \<Offer> that models sale offers:
it specifies who is the seller of the shares,
how many shares are being sold, the requested price and the expiration of the offer.
Method \<isOngoing> checks if an offer has not expired yet.
Implementations can subclass \<Offer> if they need more specific offers.
By using class \<Offer>, the \<SharedEntity> interface specifies four methods.
Method \<sharesOf> allows one to know how many shares a potential \<shareholder> (of type \<S>) holds.
It is annotated as \<@View>. In Takamaka, this means that its execution can be performed
\emph{for free}, without paying gas, since it has no side-effects. Who wants to sell
(some of) its shares calls method \<place> with a sale \<offer>.
This method is annotated as \<@Payable> since
implementations are allowed to require a payment of \<amount> coins for managing the sale.
Who buys the shares calls method \<accept> with the accepted \<offer>
and with itself as \<buyer> (the reason will be explained soon)
and becomes a new shareholder or increases
its cumulative number of shares (if it was a shareholder already).
Also this method is \<@Payable>, since its caller must pay \<amount> $\ge$ \<offer.cost>
coins to the seller.
This means that shareholders must be able to receive payments and that
is why \<S extends PayableContract>: the \<PayableContract>s are those that can receive
payments in Takamaka.
Method \<getShareholders> yields the list of the current shareholders of the entity.
It is not \<@View>, since it creates a new list.

The annotation \<@FromContract> on both \<place> and \<accept> enforces that only
contracts can call these methods. This attests, explicity, their will
to sell or buy shares. The callers must be (old or new) shareholders,
hence of type \<S>. In Takamaka, this could be written
as \<@FromContract(S.class)>. Unfortunately, Java does not allow a generic type variable \<S>
in \<S.class>. Because of this limitation,
the best we could write in Fig.~\ref{fig:shared_entity} is \<@FromContract(PayableContract.class)>,
which allows \emph{any} \<PayableContract> to call these methods, not just those of type \<S>.
Since the syntax of the language does not support our abstraction, we will have to
program explicit dynamic checks in code, as shown later.

Let us state an important property about shared entities:

\begin{tcolorbox}
  \begin{center}\emph{Consistency of Shareholders}\end{center}
  If \<sse> is a {\codesize\texttt{SharedEntity<S,O>}}
  then the elements in the list \<sse.getShareholders()> have type \<S>.
\end{tcolorbox}

\noindent
This property is important since it states that we can trust the type \<S> of
the shareholders: if we create a \<SharedEntity> and fix a specific type \<S>
for its shareholders, then only instances of \<S> will manage to become shareholders.

\begin{figure}[htbp]
  \begin{center}
    \begin{lstlisting}[language=Takamaka]
public class SimpleSharedEntity
      <S extends PayableContract,O extends Offer<S>>
      extends Contract
      implements SharedEntity<S,O> {

  private final StorageTreeMap<S,BigInteger> shares = new StorageTreeMap<>();
  private final StorageSet<O> offers = new StorageTreeSet<>();        

  public SimpleSharedEntity(S[] shareholders, BigInteger[] shares) {
    require(shareholders.length == shares.length, "length mismatch");
    for (int pos = 0; pos < shareholders.length; pos++)
      addShares(shareholders[pos], shares[pos]);
  }

  @Override @View
  public final BigInteger sharesOf(S shareholder) {
    return shares.getOrDefault(shareholder, BigInteger.ZERO);
  }

  @Override @FromContract(PayableContract.class) @Payable
  public void place(BigInteger amount, O offer) {
    require(offer.seller == caller(), "not authorized to sell");
    require(shares.containsKey(offer.seller), "only shareholders can sell");
    require(sharesOf(offer.seller).subtract(sharesOnSaleOf(offer.seller))
        .compareTo(offer.sharesOnSale) >= 0, "not enough shares to sell");
    offers.add(offer);
  }

  @Override @FromContract(PayableContract.class) @Payable
  public void accept(BigInteger amount, S buyer, O offer) {
    require(caller() == buyer, "only the future owner can buy the shares");
    require(offers.contains(offer), "unknown offer");
    require(offer.isOngoing(), "the sale offer is not ongoing anymore");
    require(offer.cost.compareTo(amount) <= 0, "not enough money");
    offers.remove(offer);
    removeShares(offer.seller, offer.sharesOnSale);
    addShares(buyer, offer.sharesOnSale);
    offer.seller.receive(offer.cost);
  }

  private BigInteger sharesOnSaleOf(S shareholder) {
    return offers.stream()
      .filter(offer -> offer.seller == shareholder && offer.isOngoing())
      .map(offer -> offer.sharesOnSale)
      .reduce(ZERO, BigInteger::add);
  }

  @Override
  public List<S> getShareholders() {
    return shares.keyList();
  }
}
    \end{lstlisting}
  \end{center}
  \caption{A simplified part of our implementation of the shared entity interface.
  Its full code is available at \url{https://github.com/Hotmoka/hotmoka/blob/master/io-takamaka-code/src/main/java/io/takamaka/code/dao/SimpleSharedEntity.java}.}\label{fig:simple_shared_entity}
\end{figure}

Fig.~\ref{fig:simple_shared_entity} shows our implementation of the \<SharedEntity> interface
in Fig.~\ref{fig:shared_entity}
by using two fields: \<shares> maps each shareholder to its amount of shares and
\<offers> collects the offers that have been placed.
The constructor populates the map \<shares>, initially.
Method \<sharesOf> simply accesses
\<shares>, by using zero as default. Method \<place> requires its \<caller()> to be
the seller identified in the \<offer>. This forbids shareholders to sell shares on behalf of others.
Moreover, this guarantees that the caller has type \<S>, like \<offer.seller>.
As we said before, this cannot be expressed with the syntax of the language.
Method \<place> further requires the seller to be a shareholder with at least \<offer.sharesOnSale>
shares not yet placed on sale. This forbids to oversell more shares
than one owns. At the end, \<place> adds the \<offer> to the set of \<offers>.
Method \<accept> requires that who calls the method must be \<buyer>. Hence, successful
calls to \<accept> can only pass the same caller for \<buyer>. This is a trick to enforce the
caller to have type \<S>, since the syntax of the language does not allow one to express it,
as we explained before. Then \<accept> requires the \<offer> to exists, to be still ongoing
and to cost no more than the \<amount> of money provided to \<accept>. If that is the case,
the \<offer> is removed from the \<offers>, shares are moved from seller to buyer (code not
shown in Fig.~\ref{fig:simple_shared_entity}) and the seller of the \<offer>
receives the required price \<offer.cost>.
Method \<getShareholders()> yields the list of the keys in the domain of map \<shares>.

It turns out that the \emph{Consistency of Shareholders} property holds if Java code
creates and populates \<SimpleSharedEntity>s.
Namely, the code in Fig.~\ref{fig:simple_shared_entity}
does not use unchecked casts, hence it is strongly-typed and
the map \<shares> actually holds values of type \<S> in its domain, only.
For this consistency result, we had to pay the price
of the dummy \<buyer> argument for method \<accept>. Without that argument,
\emph{Consistency of Shareholders} would not hold, since we could only write
\<addShares((S) caller(), offer.sharesOnSale)> in the implementation of \<accept> in
Fig.~\ref{fig:simple_shared_entity}, with an unchecked cast that makes the code
non-strongly-typed. Therefore, also contracts not of type \<S> could call \<accept>
and become shareholders.

There is, however, a problem with the reasoning
in the previous paragraph. Namely, absence of unchecked
operations guarantees strong typing \emph{of source code} in Java. But what is installed
and executed in blockchain is the Java bytecode derived from
the compilation of the code in Fig.~\ref{fig:simple_shared_entity}.
Malicious users might install in blockchain some crafted bytecode that
calls the methods of \<SimpleSharedEntity>s in order to attack
the contract. In particular,
the signature of method \<accept> declares a parameter \<buyer> of type \<S> at source code level, but
its compilation into Java bytecode declares a parameter \<buyer> of type \<PayableContract> instead.
This is because of the so called \emph{erasure} of generic types in the compilation of Java.
It entails that an attacker might install in blockchain a snippet of bytecode that calls
\<accept> and passes \emph{any} \<PayableContract>, not only those that are instances of \<S>:
the \emph{Consistency of Shareholders} property is easily violated at bytecode level.

In general, the problem arises whenever a method declares a formal parameter of generic type,
such as \<buyer> in method \<accept> in Fig.~\ref{fig:shared_entity}. Next section shows
the actual significance of the consequent security risk.

\section{An Attack to the Shared Entities Contract}\label{sec:attack}

This paper originated from an actual security issue that we found in our code
that used shared entities in order to model the validators of a blockchain.
Namely, the Hotmoka blockchain is built over Tendermint~\cite{Kwon14}, a
generic engine for replicating an application over a network of nodes. In our case,
the application is the executor of smart contracts in Java, such as that in
Fig.~\ref{fig:simple_shared_entity}. Tendermint is based on a proof of stake
consensus, which means that a selected dynamic subset of the nodes is in charge of
validating the transactions and voting their acceptance. Validator nodes are
represented by \<Validator> objects, that are externally owned accounts
with an extra identifier derived from their public key (see Fig.~\ref{fig:validator}).
This identifier is public information, reported in the blocks or easily eavesdropped.
At each block, the reward for the block is distributed to the validators.
Tendermint applications can implement their own
policy for changing the validator set dynamically. In our case, the validator set
and the distribution of the reward is implemented by a subclass
\<Validators> of \<SimpleSharedEntity> whose type \<S> for the shareholders
has been set to \<Validator>. Shares are voting power in this case.

\begin{figure}[t]
  \begin{center}
    \begin{lstlisting}[language=Takamaka]
public final class Validator extends ExternallyOwnedAccount {
  private final String id;

  public Validator(String publicKey) {
    super(publicKey);
    this.id = /* derived from publicKey as specified in Tendermint's spec */
  }

  public @View String id() {
    return id;
  }
}
    \end{lstlisting}
  \end{center}
  \caption{The representation of a validator of a Tendermint blockchain.
  Its full code is available at \url{https://github.com/Hotmoka/hotmoka/blob/master/io-takamaka-code/src/main/java/io/takamaka/code/governance/tendermint/TendermintED25519Validator.java}.}\label{fig:validator}
\end{figure}

Since shares of a \<SimpleSharedEntity> can be sold and bought, the set of validators
is dynamic. Users can sell or buy voting power in order to invest in the blockchain
and earn rewards. At each block creation, Hotmoka calls method \<getShareholders>
on the shared entity and informs the
underlying Tendermint engine about the identifiers of the validator nodes for the next blocks.
Tendermint expects such validators to mine and vote the subsequent blocks, until a change in the
validators set occurs.

It is important that the shareholders be instances of \<Validator>, since that class enforces the
match between their public key, that identifies who can use the reward sent to the validator,
and the Tendermint identifier of the validator, that identifies which node of the blockchain
must do the validation work (Fig.~\ref{fig:validator}).
If it were possible to add a shareholder of another
type \<Attacker>, the latter could declare the identifier of a node that does not correspond to its
public key (see Fig.~\ref{fig:attacker}):
the node (belonging to the \emph{victim}) would do the work while the owner
of the private key of the \<Attacker> could just wait and earn the reward.
A sort of validator's slavery.

\begin{figure}[t]
  \begin{center}
    \begin{lstlisting}[language=Takamaka]
public class Attacker extends ExternallyOwnedAccount {

  public Validator(String publicKey) {
    super(publicKey);
  }

  public @View String id() {
    return /* id of the victim node of the blockchain */
  }
}
    \end{lstlisting}
  \end{center}
  \caption{An attacker that exploits a blockchain node for validation and fraudolently earns the reward of its work.}\label{fig:attacker}
\end{figure}

\section{Fixing the Compilation of the Shared Entities Contract} \label{sec:fix}

\section{Conclusion}\label{sec:conclusion} 

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}
