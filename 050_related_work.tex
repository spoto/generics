\section{Related Work}\label{sec:related_work}

\todo{Forse questa parte va spostata.}


\textbf{Generics Compilation --} Generics is a way for writing code parametrized by type, in other words a same piece of code can be written by using a type placehorder (ie. parameter) and then instantiated it for a specific type arguments. There exists two common ways to implement generics in a programming language that are often described in literature\,\cite{generics_categories} as \textit{heterogeneous} and \textit{homogeneous}. In the heterogeneous approach the code is specialized for each instance of the generic parameter, this is the approach adopted by the C++ \emph{templates}. Conversely, the homogeneous approach is the one provided by Java or .Net, in this case only one instance of the code is maintained that is shared by all generic instances. This implementation is based on the type \emph{erasure} mechanism in which the generic parameter is replaced by the upwards bound of each instance, most often \<Object>.
%
Even if the heterogeneous approach is the most safe one, it is rarely applied in particular in resource-constrained applications, because in this case the code size  may dramatically increase as some code is duplicated \cite{generics_embedded_systems}. Conversely, the latter approach ensures a smaller consumption of resources but can lead to the problems described in this paper. \\

\noindent
\textbf{Smart contracts vulnerabilities --} It has been estimated that on average, software developers make 100 to 150 errors for every thousand lines \cite{software_engineering}.
In 2002, the National Institute of Standards and Technology (NIST) estimates that the economic costs of faulty software in the US is about tens of billions of dollars per year and represent approximately just under 1 percent of the nation's gross domestic product (GDP). The effects induced by errors in software development are even worse when such piece of software represents a smart contract for two main reasons. First of all, it is usually impossible to change a smart contract once it has been deployed, the immutability is one of its main characteristics and errors are treated as intended behaviours. Secondly, smart contracts often store and
manage critical information such as digital assets and identities. For these reason several analysis of smart contracts vulnerabilities have been performed and some static analysis tools have been developed.



\begin{itemize}
\item Solythesis \cite{solythesis_solidity_validation}: A compilation tool for smart contracts which provides an expressive language for specifying desired safety invariants. Given a smart contract and a set of user defined invariants, it is able to produce a new enriched contract which will reject all transactions that violate such invariants.

\item Another solutions which is based on bytecode rewriting is presented in \cite{bytecode_rewriting}, where the authors propose the enforcement of security polices through the enhancement of EVM bytecode. More specifically, the disassembled bytecode is instrumented through new security guard code that enforces the desired policy. Their initial efforts are mainly focused on the  verification of arithmetic operations, such as the prevention of overflows; while in the future they will focus on
adding the verification of memory access operations.

\item SafeVM \cite{safevm}:  A  verification tool for Ethereum smart contracts which directly works on EVM bytecode and exploits the state-of-the-art verification engines already available for C programs. The basic idea is to take as input a smart contract in compiled EVM\ bytecode which can eventually contain some \<assert> or \<require> annotations, then such bytecode is decompiled and converted into a C program with \<ERROR> annotations. This produced C program can be verified by using existing verification tools.
 
\item In \cite{hol_smart_constracts} the authors propose the use of the existing Isabelle/HOL tool with the specification of a formal logic for EVM bytecode, in order to provide a verification tool for Ethereum smart contracts. More specifically, the desired properties  of contracts are stated in a pre/postcondition style, while the verification is done by recursively structuring contracts as a set of basic blocks
down to the level of instructions.

\item Scilla \cite{scilla} is a new programming language for safe smart contracts which as been tailored taking   System F as a foundational calculus. It is able to provide strong safety guarantees by means of type soundness. Thanks to its minimalistic nature, it has been possible to define also a generic and extensible framework for lightweight verification of smart contracts by means of user-defined domain-specific analyse. \todo{Ci sono i generics oppure essendo un linguaggio minimale non si pongono il problema??}



 
\end{itemize}

Given the plurality of verification tools that have been developed for indentifying security bugs in smart contracts, a unified and standard approach for evaluating their accuracy and performances have been developed in \cite{effectiveness_analysis_tools}. This automated and systematic approach, called SolidiFI, consists in injecting bugs into all potential locations in a smart contract, in order to introduce different kinds of vulnerabilities, and then using several static analysis tools to identify which bugs each of them is able to detect.


